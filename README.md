Вавилина Анастасия ИТ-7

Постановка задачи:
Реализуйте с помощью двусвязного циклического списка следующую игру:
Ученики школы встают в круг. Один ученик пишет программу, генерирующую
случайное целое число из промежутка [–10;10]. Если выпало положительное
число, то отсчет ведется «по часовой стрелке», если отрицательное, то «против
часовой». Ученик, на котором остановился счет, не выбывает из круга, а делает
«доброе дело» и уровень его рейтинга увеличивается на 1. Следующий отсчет
начинается с ученика, стоящего в круге рядом с тем, который только что делал
«доброе дело», с правого (если отсчет ведется по часовой стрелке) или с левого
(против часовой). После того, как игра всем надоела, нужно вывести список
учеников в порядке невозрастания рейтинга. Если имеется несколько
учеников с одинаковым рейтингом, то их нужно выводить в том порядке, в
котором они поступили в список. Исходный список фамилий учеников для
игры находится в текстовом файле. В начале игры рейтинг каждого ученика
равен 0. Во время игры нужно выводить протокол: какое случайное число
выпало, какой ученик делал доброе дело и рейтинг ученика после совершения
доброго дела. Количество раундов игры вводится пользователем с
клавиатуры.

1. Соответствие задаче
  Игра моделирует круг учеников, где:
-Нужно перемещаться в обе стороны (по/против часовой стрелки).
-После последнего ученика должен идти первый (замкнутость).
  Двусвязный циклический список идеально подходит, так как:
-Каждый узел (StudentNode) хранит ссылки на предыдущий и следующий элементы (prev, next).
-Последний элемент связан с первым, образуя кольцо.

2. Преимущества структуры
  Требование - Реализация в двусвязном циклическом списке
  Движение в обе стороны - Есть prev и next — можно идти в любом направлении.
  Замкнутость (круг) - head.prev указывает на хвост, tail.next — на голову.
  Быстрый доступ к соседям - Получение следующего/предыдущего за O(1).
  Гибкость - Легко добавлять/удалять учеников без перестройки структуры.
3. Сравнение с другими структурами
  Структура - Проблемы для данной задачи
  Обычный список (массив) - Нет связей между концом и началом. Перемещение за O(n).
  Односвязный список - Нет движения назад (prev). Не замкнут.
  Очередь (Queue) - Только FIFO, нет произвольного доступа.
  Дек (Deque) - Не поддерживает цикличность «на лету».
Пример:
  Для шага -5 (против часовой стрелки) в списке из 3 учеников:
  -Двусвязный список: быстро перейдет на prev 5 раз (фактически на 2 шага из-за % size).
  -Массив: потребовал бы сложных вычислений индексов с учетом переполнения.

4. Эффективность операций
-Добавление ученика (add_student)
  Вставка в конец за O(1) (так как есть ссылка на head.prev — хвост).
-Поиск ученика (find_student)
  Линейный обход O(n), но это редко используется в игре.
-Перемещение по кругу (get_student_by_steps)
  Шаги выполняются за O(1) на каждый переход (т.к. next/prev — прямые ссылки).
-Сортировка (get_sorted_list)
  Стандартная сортировка Python за O(n log n).


Алгоритм решения:
1.	Создание структуры данных.
  Класс StudentNode (хранение данных между узлами):
  1.	name(str) – фамилия участника.
  2.	rating(int) – текущий рейтинг(начинается с 0).
  3.	prev(StudentNode) – ссылка на предыдущий узел.
  4.	next(StudentNode) – ссылка на следующий узел.

2.	Реализация двусвязного циклического списка.
  Класс StudentCircle (управление кругом учеников):
  1.	add_student(self, name) – добавляет нового ученика в круг.
    1.1.	Создаёт новый узел.
    1.2.	Если круг пустой делает узел головой и замыкает ссылки на себя.
    1.3.	Иначе вставляет узел перед головой, сохраняя цикличность.
  2.	find_student(self, name).
    2.1.	Ищет ученика по имени (без учёта регистра).
    2.2.	Линейный обход круга с проверкой node.name.lower() ==  name.lower().
  3.	get_student_steps(self, start_node, steps) - перемещается на steps узлов от start_node.
    3.1.	Определяет направление (знак steps).
    3.2.	Делает abs(steps) % size шагов, чтобы избежать лишних оборотов.
  4.	print_circle(self)  -  выводит текущее состояние круга.
    4.1.	Проверяет не пуст ли круг. 
    4.2.	Начиная с головы, выводит каждого ученика.
    4.3.	Завершает обход при возврате к голове.
3.	Чтение данных и настройка игры.
  Функция read_students_from_file(filename)  -  загружает список учеников из файла.
  1.	Открывает файл, читает строки, пропускает пустые.
  2.	Обрабатывает ошибки (например, отсутствие файла).

4.	Игровой процесс.
  Функция main()
  1.	Инициализация
    1.1.	Чтение файла: создание круга (StudentCircle).
    1.2.	Выбор начального ученика (select_starting_student).
  2.	Раунды (для каждого раунда):
    2.1.	Запрос числа (get_number_input).
    2.2.	Поиск ученика (get_student_steps).
    2.3.	Обновление рейтинга.
  3.	Итоги
    3.1.	Сортировка (get_sorted_list).
    3.2.	Вывод результатов.
5.	Сортировка и вывод.
  Метод get_sorted_list():
  1.	Собирает список кортежей (name, rating, original_index).
  2.	Сортирует по убыванию rating, затем по original_index


1. Обработка исключений
Используется в следующих местах:

a) Чтение файла (read_students_from_file)
Почему здесь?
  Операции с файлами подвержены ошибкам (нет файла, нет прав доступа, повреждение данных).
Какие исключения обрабатываются:
  FileNotFoundError — если файл отсутствует.
  Exception — все остальные ошибки (например, проблемы с кодировкой).
Действия:
  Вывод понятного сообщения и аварийное завершение (sys.exit(1)), чтобы избежать дальнейших ошибок.

b) Ввод числа раундов (main)
Почему здесь?
  Пользователь может ввести не число (например, буквы).
Обрабатывается: ValueError — если ввод нельзя преобразовать в целое число.
Действия:
  Программа просит повторить ввод, а не завершается.

  
2. Классы и ООП
a) Класс StudentNode
Инкапсуляция:
Объединяет данные (имя, рейтинг) и связи (prev, next) в одном объекте.
Поля защищены от прямого изменения (хотя в Python нет строгой инкапсуляции, соглашение — не менять их без методов).

b) Класс StudentCircle
Инкапсуляция:
Скрывает внутреннюю структуру списка (указатели head, size).
Работа с кругом возможна только через методы (add_student, find_student и др.).

Пример инкапсуляции:
Пользователь класса не знает, как хранятся ученики, но может добавить/найти их через методы.

c) Наследование и полиморфизм
В данном коде не используются, так как:
  Нет иерархии классов (все уникальные сущности).
  Нет переопределения методов (полиморфизм не нужен).


3. Почему такие принципы ООП?
Принцип	-                       - Применение в коде -	                                      - Зачем?-
Инкапсуляция- Данные ученика и методы работы с кругом скрыты в классах - Защищает внутреннюю логику, упрощает изменение кода
Наследование -	             - Не используется. -	                       - В задаче нет общих черт для наследования.
Полиморфизм -	               - Не используется. -	              - Нет методов с одинаковыми именами, но разной реализацией.


4. Примеры инкапсуляции
a) Защита данных в StudentNode:

class StudentNode:
    def __init__(self, name):
        self.name = name  # Открытое поле (но в Python нет приватности).
        self.rating = 0   # Рейтинг изменяется только через методы класса.
        
b) Управление списком в StudentCircle:

def add_student(self, name):
    new_node = StudentNode(name)
    # Внутренняя логика связывания узлов скрыта от пользователя класса.
    if self.head is None:
        new_node.next = new_node
        ...

5. Где и почему нет обработки исключений?
В методах класса StudentCircle (например, get_student_by_steps):
  Не обрабатываются ошибки вроде steps = None, так как:
    - Число steps контролируется в get_number_input().
    - Если ошибка все же возникнет, её лучше увидеть сразу (Fail Fast).      

1. import random
 - Модуль random предоставляет функции для генерации случайных чисел
Конкретное применение в коде:
   -Генерация случайного числа от -10 до 10, когда пользователь не вводит число вручную
   -Используется в функции get_number_input(): random.randint(-10, 10)
Почему важен:
   -Позволяет добавить элемент случайности в игру, делая ее более интересной

2. import sys
- Модуль sys предоставляет доступ к системным функциям и параметрам
Конкретное применение в коде:
  -Аварийное завершение программы при ошибках чтения файла: sys.exit(1)
  -Используется в функциях обработки ошибок в read_students_from_file()
Почему важен:
  -Позволяет корректно завершить программу при критических ошибках
  -Дает возможность вернуть код ошибки операционной системе (1 - ошибка)
